{"version":3,"sources":["../../src/lib/keepBranchesIncluding.ts"],"names":["keepBranchesIncluding","search","obj","value","reduce","acc","Array","isArray","node","block","isRoot","key","includes","path","pathAcc","index","push","has","level","set","Object","keys","length"],"mappings":";;;;;;;AAAA;;AAMA;;;;;;;;AAQO,MAAMA,qBAAqB,GAAG,CACnCC,MADmC,EAEnCC,GAFmC,KAGb;AACtB,QAAM;AAAEC,IAAAA;AAAF,MAAY,gBAASD,GAAT,EAAcE,MAAd,CAAqB,UAErCC,GAFqC,EAGrC;AACA;AACA,QAAIC,KAAK,CAACC,OAAN,CAAc,KAAKC,IAAnB,CAAJ,EAA8B;AAC5B,WAAKC,KAAL,GAD4B,CACf;AACd;;AAED,QAAI,CAAC,KAAKC,MAAV,EAAkB;AAChB;AACA;AACA;AACA,UAAI,KAAKC,GAAL,IAAYV,MAAM,CAACW,QAAP,CAAgB,KAAKD,GAArB,CAAhB,EAA2C;AACzC,aAAKF,KAAL,GADyC,CAC5B;;AACb,aAAKI,IAAL,CAAUT,MAAV,CAA2B,CAACU,OAAD,EAAUD,IAAV,EAAgBE,KAAhB,KAA0B;AACnDD,UAAAA,OAAO,CAACE,IAAR,CAAaH,IAAb;;AACA,cAAI,CAACR,GAAG,CAACY,GAAJ,CAAQH,OAAR,CAAL,EAAuB;AACrB,gBAAI,KAAKI,KAAL,KAAeH,KAAK,GAAG,CAA3B,EAA8B;AAC5BV,cAAAA,GAAG,CAACc,GAAJ,CAAQL,OAAR,EAAiB,KAAKN,IAAtB;AACD,aAFD,MAEO;AACLH,cAAAA,GAAG,CAACc,GAAJ,CAAQL,OAAR,EAAiB,EAAjB;AACD;AACF;;AACD,iBAAOA,OAAP;AACD,SAVD,EAUG,EAVH;AAWD;AACF;;AAED,WAAOT,GAAP;AACD,GA9BiB,EA+BlB,gBAAS,EAAT,CA/BkB,CAAlB;;AAiCA,MAAIe,MAAM,CAACC,IAAP,CAAYlB,KAAZ,EAAmBmB,MAAvB,EAA+B;AAC7B,WAAOnB,KAAP;AACD;;AAED,SAAO,IAAP;AACD,CA1CM","sourcesContent":["import { traverse, Traverse, TraverseContext } from '..'\n\ninterface GenericObj {\n  [key: string]: any\n}\n\n/**\n * given an object, keep only those branches containing the given segments. The\n * resulting object will maintain the structure of the original object but\n * excluding from it any branch that doesn't match with some of the given\n * segments\n * @param search string to search for\n * @param obj object to search in\n */\nexport const keepBranchesIncluding = (\n  search: string[],\n  obj: GenericObj\n): GenericObj | null => {\n  const { value } = traverse(obj).reduce(function(\n    this: TraverseContext,\n    acc: Traverse<{}>\n  ) {\n    // do not traverse any further if the current node is an array\n    if (Array.isArray(this.node)) {\n      this.block() // ==> skip further traversing of this branch\n    }\n\n    if (!this.isRoot) {\n      // if the current segment of the current branch (this.key) match\n      // any of the given search words, then include this branch into our\n      // collection but block any further traversing on it\n      if (this.key && search.includes(this.key)) {\n        this.block() // ==> skip further traversing of this branch\n        this.path.reduce<string[]>((pathAcc, path, index) => {\n          pathAcc.push(path)\n          if (!acc.has(pathAcc)) {\n            if (this.level === index + 1) {\n              acc.set(pathAcc, this.node)\n            } else {\n              acc.set(pathAcc, {})\n            }\n          }\n          return pathAcc\n        }, [])\n      }\n    }\n\n    return acc\n  },\n  traverse({}))\n\n  if (Object.keys(value).length) {\n    return value\n  }\n\n  return null\n}\n"],"file":"keepBranchesIncluding.js"}